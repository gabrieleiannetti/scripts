#!/usr/bin/env ruby
#
# Copyright 2016 Victor Penso
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

require 'ostruct'
require 'getoptlong'
require 'logger'
require 'json'
require 'date'
require 'erb'

class Hash

  def self.autonew(*args)
    new(*args){|hsh, key| hsh[key] = Hash.new(&hsh.default_proc) }
  end

end

class Array

  def median

    val = '-'

    unless self.empty?

      # Average and median wait time of all jobs in queue 
      lowest = self.min
      highest = self.max
      total = self.inject(:+)
      length = self.length
      average = total.to_f/length
      sorted = self.sort
      median = if length > 0
                 if length % 2 == 1
                   sorted[length/2]
                 else
                   (sorted[length/2 - 1] + sorted[length/2]).to_f / 2
                 end
               else
                 0
               end

      val = median.to_i

    end

    return val

  end

end

#
# Interface to the command-line environment
#
module System

  module_function

  ##
  # Execute a command passed as parameter an return the output
  # on success. Otherwise the method returns Nil indicating
  # a problem on execution.
  def exec(command, file = '')
    if file.empty?
      command << ' 2>&1'
    # Users can optionally provide a file to store the output into
    #
    else
      # Avoid piping the content threw the Ruby process
      #
      command << " 1> #{file}"
    end
    $logger.info "<#{self.class}##{__method__.to_s}> #{command}"
    # Execute command as subprocess and return the exit code
    pipe = IO.popen(command)
    # Get the process ID from the child
    pid = pipe.pid
    # Read the output from the stream
    output = pipe.read
    # Wait for successful return and pass back the code to the caller
    Process.wait(pid)
    state=$?
    $logger.debug "Returned with #{state}"
    if state == 0
      return output
    else
      $logger.warn "Failed to execute [#{command}]"
      return nil
    end
  end

  ##
  # Execute a command and transform the output line by line
  # into an array splitting each line using a delimiter into
  # a second level array.
  #
  def self.exec_split_lines(command, delimiter = ' ')
    r_val = Array.new
    # Remove line-feed and leading white-space
    #
    command = command.gsub(/^  */,'').gsub(/\n/,' ')
    # Execute the command and split the output by line
    #
    output = System::exec(command)
    $logger.info "<#{self.class}##{__method__.to_s}> Split lines by field separator"
    output.each_line do |line|
      # Use the defined delimiter to split the fields per line
      #
      r_val << line.split(delimiter).map(&:strip)
    end
    # Pass the output multi-dimensional array to the caller
    #
    r_val
  end

end

##################################################################
##################################################################

class Sacct

  FIELDS = %w(
    jobid
    cluster
    partition
    account
    group
    gid
    user
    uid
    submit
    priority
    eligible
    start
    end
    elapsed
    exitcode
    state
    nnodes
    ncpus
    ntasks
    reqcpus
    reqmem
    timelimit
    cputime
    cputimeraw
    nodelist
    jobname
    alloccpus
  )

  # List of job states queried during data export
  #
  STATES = %w(
    cancelled
    completed
    failed
    node_fail
    timeout
  )

  DEFAULT_OPTIONS = %w(
    --allusers
    --noheader
    --allocations
    --parsable2
  )

  TIME_FORMAT = '%Y-%m-%dT%H:%M:00'

  RUNTIMES = %w(
    lt_5m
    lt_1h
    lt_4h
    lt_8h
    lt_12h
    lt_1d
    lt_7d
    gt_7d
  )

  OBJECTS = %w(
   account
   partition
   user
  )

  attr_reader :opts, :data, :raw_data

  def initialize()
    @opts = DEFAULT_OPTIONS
    @opts << "--state #{states}"
    @opts << "--format #{fields}"
    @delimiter = '|'
    @node_regex = String.new
    @raw_data = Array.new
    @data = { 'runtime' => 0}
    OBJECTS.each {|_| @data[_] = Hash.new}
  end

  def start_time(time)
    @start_time = "_#{time}"
    @opts << "--starttime #{time}"
  end

  def end_time(time = '')
    time = Time.now.strftime TIME_FORMAT if time.empty?
    @end_time = "_#{time}"
    @opts << "--endtime #{time}"
  end

  def account(account)
    @opts << "--accounts #{account}"
  end

  def user(user)
    @opts << "--user #{user}"
  end

  def partition(partition)
    @opts << "--partition #{partition}"
  end

  def node_regex(regex)
    @node_regex = regex
  end

  def parse
    exec()
    transform()
    post_process()
  end

  private

  def skeleton
    skel = {
      'accounts' => Array.new,
      'jobs' => 0,
      'partitions' => Array.new,
      'runtime' => 0,
      'users' => Array.new,
      'qwmedian' => Array.new
    }
    skel.merge(runtimes_h).merge(states_h)
  end

  def transform

    # Initialize the basic data structure..
    OBJECTS.each do |object|
      index = field_index(object) + 1
      # Do not implement this in Ruby code...
      elems = System::exec %Q<cat #{data_file} | cut -d'#{@delimiter}' -f#{index} | sort | uniq>
      elems.each_line do |elem|
        @data[object][elem.chop] = skeleton
      end
    end

    $logger.info "<#{self.class}##{__method__.to_s}>"

    # Avoid memory slurping by reading the lines one-by-one into memory
    #
    File.foreach(data_file) do |line|

      line = line.chop.split(@delimiter)

      unless @node_regex.empty?
        next unless line[field_index 'nodelist'] =~ Regexp.new(@node_regex)
      end

      runtime = line[field_index 'cputimeraw'].to_i
      account = line[field_index 'account']
      user = line[field_index 'user']
      partition = line[field_index 'partition']
      j_state = line[field_index 'state']

      @data['runtime'] += runtime
      OBJECTS.each do |key|
        value = line[field_index key]
        @data[key][value]['accounts'] = (@data[key][value]['accounts'] << account).uniq
        @data[key][value]['jobs'] += 1
        @data[key][value]['runtime'] += runtime
        @data[key][value]['users'] = (@data[key][value]['users'] << user).uniq
        @data[key][value]['partitions'] = (@data[key][value]['partitions'] << partition).uniq
        @data[key][value][state(j_state)] += 1
        @data[key][value][runtimes_key(runtime)] += 1
        # This is expensive in terms of run-time and memory foot print
        if $options.format.include? 'qwmedian'
          @data[key][value]['qwmedian'] << waittime(line[field_index 'start'],line[field_index 'end']) 
        end
      end
    end

  end

  def post_process

    $logger.info "<#{self.class}##{__method__.to_s}> Post process data"

    OBJECTS.each do |key|
      @data[key].each do |value,data|
        # Relative percent of the consumed resources according to the CPU seconds
        r_perc = sprintf '%.2f', (data['runtime'].to_f/@data['runtime']) * 100
        @data[key][value]['useperc'] = r_perc
         # Median wait time of jobs in queue
        @data[key][value]['qwmedian'] = data['qwmedian'].median
      end
    end

  end

  def fields ; FIELDS.join(',') end
  def field_index(field) ; FIELDS.index(field) end
  # This may include states  like "CANCELLED by 1234",
  # therefore everything after the first space is removed
  def state(s) ; s.gsub(/\s.*/,'').downcase end
  def states ; STATES.join(',') end
  def states_h ; Hash[ STATES.map {|_| [_,0]} ] end

  def runtimes_h ; Hash[ RUNTIMES.map {|_| [_,0]} ] end
  def runtimes_key(seconds)
    case
    when seconds < 300    ; 'lt_5m'
    when seconds < 3600   ; 'lt_1h'
    when seconds < 14400  ; 'lt_4h'
    when seconds < 28800  ; 'lt_8h'
    when seconds < 43200  ; 'lt_12h'
    when seconds < 86400  ; 'lt_1d'
    when seconds < 604800 ; 'lt_7d'
    else                  ; 'gt_7d'
    end
  end

  def waittime(start_time,end_time)
    submit_epoch = DateTime.strptime(start_time,'%Y-%m-%YT%H:%M').to_time.to_i
    start_epoch = DateTime.strptime(start_time,'%Y-%m-%YT%H:%M').to_time.to_i
    wait_time_secs = start_epoch - submit_epoch
    wait_time_secs > 31449600 ? 0 : wait_time_secs
  end


  def humanize_secs(seconds)
    days = seconds / (60*60*24)
    seconds = seconds % (60*60*24)
    hours = Time.at(seconds).utc.strftime('%H:%M')
    days > 0 ? "#{days}-#{hours}" : hours
  end

  def data_file
    "/tmp/#{ENV['USER']}_sacct#{@start_time}#{@end_time}.csv"
  end

  def exec
    # It is very expensive to query the Slurm accounting database
    # therefore make sure to buffer the result on disc to support
    # multiple executions of the program on the same time frame.
    if File.exist? data_file
      $logger.info "<#{self.class}##{__method__.to_s}> File exists #{data_file}"
    else
      # Gather the accounting data from Slurm
      #
      System::exec("sacct #{@opts.join(' ')}",data_file)
    end 
  end

end

#
# Print an array as table with padded columns
#
class Table

  def initialize(output)
    @output = output
  end

  def self.print(table)
    Table.new(table).rows
  end

  def rows
    form = format()
    rows = String.new
    @output.each do |row|
      $logger.debug("#{row.inspect}")
      rows << sprintf("#{form}\n", *row)
    end
    return rows
  end

  def format
    format = Array.new
    columns = @output.first.length
    0.upto(columns-1) do |column|
      format << "%#{field_width(column)}s"
    end
    return format.join(' ')
  end

  def field_width(field = 0)
    max_width = 0
    @output.each do |row|
      elem = row[field].to_s
      next if elem.empty?
      width = elem.length
      max_width = width if width > max_width
    end
    return max_width
  end

end

module HTML

  PURPLE_4 = '#551A8B'
  PURPLE_3 = '#7D26CD'
  MAGENTA_3 = '#CD00CD'
  MEDIUMORCHID_1 = '#E066FF'
  PLUM = '#DDA0DD'
  THISTLE_2 = '#EED2EE'

  module_function

  def num_with_delimiter(num, delim = ';psbn&')
    num.to_s.chars.to_a.reverse.each_slice(3).map(&:join).join(delim).reverse
  end

  def runtime(val)
    l = val.to_s.length
    color = if    l > 9   ; PURPLE_4
            elsif l > 8   ; PURPLE_3
            elsif l > 7   ; MAGENTA_3
            elsif l > 6   ; MEDIUMORCHID_1
            elsif l > 5   ; PLUM
            else          ; THISTLE_2
            end
    %Q[<span style="color:#{color}">#{num_with_delimiter val}</span>]
  end

  # Returns a colorized value from a user defined color
  # configuration if present...
  #
  def map_style(key, val)
    # Check if the user configuration contains color mapping
    # for the given key
    #
    if $config.has_key? 'color' and
       $config['color'].has_key? key and 
       $config['color'][key].has_key? val
      # Retrieve the color information
      #
      color = $config['color'][key][val]
      # Embed the color information into a span tag, and
      # return the HTML code to the caller
      #
      return %Q[<span style="color:#{color}">#{val}</span>]
    end
    # Return the original value if mapping is not possible
    #
    val
  end

end



exec_name = File.split(__FILE__)[-1]
HELP = <<EOF
Read accounting data from Slurm and accumulate statistics:

#{exec_name} [<options>] <start_time> [<end_time>]

  start_time                 Select accouting data after start time
                             Time format like `sacct`...
  end_time                   Select accounting data before end time
                             (default is now)

  --account, -a <acc,acc>    Limit the output to a given list of accounts
  --config-file, -c <path>   Configure the HTML output
  --debug, -D                Show stacktraces in case of errors
  --format, -f <field,field> List of fields to include in output
  --format-list, -F          List of fields available to print
  --group-by, -g <group>     Group ouput by account, partition oser user
  --help                     Show this help information
  --html, -h                 Print output as HTML table
  --no-header, -H            Do not print a table header in output
  --node-regex, -n <regex>   Regular expression to select a subset of nodes
  --partition, -p <par,par>  Limit the output ot a given list of partitions
  --print-data               Print the parsed and processed data
  --print-raw-data           Print data from the accounting database
  --sort-by, -s <field>      Sort the output by selected field
  --user, -u <usr,usr>       Limit the output to a given list of users
  --version                  Print program version
EOF

EXAMPLE = <<EOF
Print default statistics for a given time:

   >>> #{exec_name} 2016-06-26T00:00:00 2016-06-27T23:59:59

EOF


begin

  #stdin = $stdin.tty? ? String.new : $stdin.read

  DEFAULT_FORMAT = %w(
    accounts
    useperc
    runtime
  )

  FORMAT_OPTIONS = %w(
    accounts
    users
    partitions
    useperc
    shareperc
    qwmedian
    runtime
    jobs
    completed
    cancel
    failed
    nodefail
    timeout
    lt_5m
    lt_1h
    lt_4h
    lt_8h
    lt_12h
    lt_1d
    lt_7d
    gt_7d
  )

  $config = Hash.new

  $options = OpenStruct.new
  $options.config_file = String.new
  $options.debug = false
  $options.format = DEFAULT_FORMAT
  $options.group_by = 'account'
  $options.html = false
  $options.node_regex = String.new
  $options.node_header = false
  $options.print_data = false
  $options.print_raw_data = false
  $options.sort_by = 'runtime'

  $logger = Logger.new($stderr)
  # Adjust the time format used for the logger
  $logger.datetime_format = "%Y-%m-%dT%H:%M:%S"
  $logger.formatter = proc do |severity, datetime, progname, message|
    "[#{datetime.strftime($logger.datetime_format)}] #{severity} -- #{message}\n"
  end
  $logger.level = Logger::WARN

  sacct = Sacct.new

  GetoptLong.new(
    ['--account','-a',GetoptLong::REQUIRED_ARGUMENT],
    ['--config-file','-c',GetoptLong::REQUIRED_ARGUMENT],
    ['--debug','-D',GetoptLong::NO_ARGUMENT],
    ['--example',GetoptLong::NO_ARGUMENT],
    ['--format','-f',GetoptLong::REQUIRED_ARGUMENT],
    ['--format-list','-F',GetoptLong::NO_ARGUMENT],
    ['--group-by','-g',GetoptLong::REQUIRED_ARGUMENT],
    ['--help',GetoptLong::NO_ARGUMENT],
    ['--html','-h',GetoptLong::NO_ARGUMENT],
    ['--log-level','-L',GetoptLong::REQUIRED_ARGUMENT],
    ['--node-regex','-n',GetoptLong::REQUIRED_ARGUMENT],
    ['--no-header','-H',GetoptLong::NO_ARGUMENT],
    ['--partition','-p',GetoptLong::REQUIRED_ARGUMENT],
    ['--print-data',GetoptLong::NO_ARGUMENT],
    ['--print-raw-data',GetoptLong::NO_ARGUMENT],
    ['--sort-by','-s',GetoptLong::REQUIRED_ARGUMENT],
    ['--user','-u',GetoptLong::REQUIRED_ARGUMENT],
    ['--version',GetoptLong::NO_ARGUMENT]
  ).each do |opt,arg|
    case opt
    when '--account'
      sacct.account arg
    when '--config-file'
      raise("#{arg} not existing!") unless File.exists? arg
      $options.config_file = arg
      $config = JSON.parse File.read($options.config_file)
    when '--debug'
      $options.debug = true
      $logger.level = Logger::DEBUG
    when '--example'
      $stdout.puts EXAMPLE
      exit 0
    when '--format'
      format = Array.new
      arg.split(',').each do |f|
        raise("Format option #{f} not supported") unless FORMAT_OPTIONS.include? f
        format << f
      end
      $options.format = format
    when '--format-list'
      $stdout.puts FORMAT_OPTIONS.join("\n")
      exit 0
    when '--group-by'
      groups = %w(account partition user)
      if groups.include? arg
        $options.group_by = arg
      else
        raise("Group by: #{groups.('|')}")
      end
    when '--help'
      $stdout.puts HELP
      exit 0
    when '--html'
      $options.html = true
    when '--log-level'
      $logger.level = case arg
      when 'warn'
        Logger::WARN
      when 'debug'
        Logger::DEBUG
      when 'fatal'
        Logger::FATAL
      else
        Logger::INFO
       end
    when '--no-header'
      $options.no_header = true
    when '--node-regex'
      sacct.node_regex arg
    when '--partition'
      sacct.partition arg
    when '--print-data'
      $options.print_data = true
    when '--print-raw-data'
      $options.print_raw_data = true
    when '--sort-by'
      raise("Sort option #{arg} not supported") unless FORMAT_OPTIONS.include? arg
      $options.sort_by = arg
    when '--user'
      sacct.user arg
    when '--version'
      $stdout.puts 0.58
      exit 0
    end
  end

  # Users are required to define a start time
  sacct.start_time ( ARGV.shift || raise('Define a start time in the format YYYY-MM-DDTHH:MM:SS') )
  # Users can optionally define an end time
  sacct.end_time(ARGV.shift || '')
  sacct.parse

  if $options.print_raw_data
    $stdout.puts sacct.raw_data
    exit 0
  end

  if $options.print_data
    $stdout.puts JSON.pretty_generate sacct.data
    exit 0
  end

  data = sacct.data[$options.group_by]

  rel = {}
  data.each{|n,d| rel[n] = d[$options.sort_by] }
  order = rel.sort_by{|k,v| v}
  order = order.reverse unless %w(accounts partitions users).include? $options.sort_by
  order = order.to_h.keys

  # Do not accounts/users/partitions to the output if no runtime has been accumulated
  order.delete_if{|elem| data[elem]['runtime'] == 0 }

  if $options.html
    $stdout.puts ERB.new(DATA.read,nil,'-').result(binding)
  else
    table = Array.new
    table << $options.format.map(&:upcase) unless $options.no_header
    order.each do |elem|
      row = Array.new
      $options.format.each do |field|
        val = data[elem][field]
        val = val.join(',') if val.class == Array
        row << val
      end
      table << row
    end
    $stdout.puts Table::print table
  end

rescue => exc
  $stderr.puts "ERROR: #{exc.message}"
  $stderr.puts " use -h for detailed instructions"
  if $options.debug
    $stderr.puts '-- Stack Trace --'
    $stderr.puts exc.backtrace
  else
    $stderr.puts 'You may want run this in debug mode with \'-d\''
  end
  exit 1
end

exit 0

__END__
<table>

  <% if not $options.no_header -%>
  <thead>
    <tr><% $options.format.each do |field| -%><th><%= field.capitalize %></th><% end -%></tr>
  </thead>
  <% end -%>

  <tbody>
  <% order.each do |elem| -%>
    <tr>
    <% $options.format.each do |field| -%>
      <td><%=
        value = data[elem][field]
        case field
        when 'accounts','partitions','users'
          value[0..2].map{|_| HTML::map_style field,_}.join(',')
        when 'runtime' ; HTML::runtime(value)
        else
          value
        end
      -%></td>
    <% end -%>
    </tr>
  <% end -%>
  </tbody>
</table>
