#!/usr/bin/env ruby
#
# Copyright 2015 Victor Penso
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

require 'ostruct'
require 'getoptlong' 
require 'logger'

class System 
  def self.exec(command)
    command = command.gsub(/\n/," ").strip.gsub(/\s+/,' ')
    command + ' 2>&1'
    $logger.debug "Exec [#{command}]"
    # Execute command as subprocess and return the exit code
    pipe = IO.popen(command)
    # Get the process ID from the child
    pid = pipe.pid
    # Read the output from the stream
    output = pipe.read
    # Wait for successful return and pass back the code to the caller
    Process.wait(pid)
    state=$?
    $logger.debug "Returned with #{state}"
    if state == 0
      return output.gsub(/^$\n/, '')
    else
      $logger.warn "Failed to execute [#{command}]"
      return nil
    end
  end
end

class Hash
  def self.autonew(*args)
    new(*args){|hsh, key| hsh[key] = Hash.new(&hsh.default_proc) }
  end
end

module CLI
  class Table
    def initialize(output)
      @output = output
    end
    def self.print(table)
      Table.new(table).rows
    end
    def rows
      form = format()
      rows = String.new
      @output.each do |row|
        $logger.debug("#{row.inspect}")
        rows << sprintf("#{form}\n", *row)
      end
      return rows
    end
    def format
      format = Array.new
      columns = @output.first.length
      0.upto(columns-1) do |column|
        format << "%-#{field_width(column)}s"
      end
      $logger.debug("Table format #{format}")
      return format.join(' ')
    end
    def field_width(field = 0)
      max_width = 0
      @output.each do |row|
        elem = row[field].to_s
        next if elem.empty?
        width = elem.length
        max_width = width if width > max_width
      end
      return max_width
    end
  end
end



exec_name = File.split(__FILE__)[-1]
HELP = <<EOF
#{exec_name} [options] [command] [subcommand] 

Commands:
  j | jobs                      state of jobs 
  n | nodes                     state of execution nodes
  r | report                    accounting statistics

Sub-Commands:
  jobs   c | comp  | completed  jobs completed after execution
  jobs   f | fail  | failed     jobs finished with a failure
  jobs   p | pend  | pending    pending jobs
  jobs   r | run   | running    jobs currenlty being executed
  nodes  a | alloc | allocated  nodes executing jobs
  nodes  d | defect             nodes removed from service
  nodes  i | idle               nodes with available resources
  nodes  u | users              list users of each node
  report a | account            consumed CPU time by account (last 30 days)
  report u | users              consumed CPU time by users (last 30 days)

Options:
  --debug, -d                   show stacktraces in case of errors
  --help, -h                    show this help information
  --version, -v                 print program version
EOF


class Jobs

  def self.running
    table = Array.new
    command = "
      squeue 
        --states RUNNING 
        --format '%9T %.11M %.11L %9P %8u %10a' 
        --sort '-M,L' 
        --noheader 
        | uniq -f3 -c 
      "
    table << ['Jobs','State','Run-Time','Time-Left','Partition','User','Account']
    System::exec(command).split("\n").each do |line|
      table << line.split(' ')
    end
    $stdout.puts CLI::Table.print(table)
  end

  def self.pending
    command = "
      squeue
        --all
        --sort '-Q,P,u,C,D,l,t' -t pd
        --format '%9T %8Q %8u %10a %9P %.4C %5D %11l %8f %6b %6q'
        --noheader
        | uniq -c
    "
    table = Array.new
    table << ['Jobs','State','Priority','User','Account','Partition','CPUs','Nodes','Time-Limit','Features','GRES','QoS']
    System::exec(command).split("\n").each do |line|
      table << line.split(' ')
    end
    $stdout.puts CLI::Table.print(table)
    $stdout.puts
    command = "
      squeue 
        --all 
        --state pending 
        --format '%9T %V %8Q %8u %10a %9P %r' 
        --noheader 
        | uniq -f 2 -c 
        | sort -k 3
    "
    table = Array.new
    table << ['Jobs','State','Submitted','Priority','User','Account','Partition','Reason']
    System::exec(command).split("\n").each do |line|
      table << line.split(' ')
    end
    $stdout.puts CLI::Table.print(table)
  end

  def self.completed
    command = '
      sacct --state completed
          --noheader
          --allusers
          --starttime $(date --date="1 days ago" +"%Y-%m-%d")
          --format end,user,account,state,nnodes
          --allocations
          | sort -k 1
          | uniq -f 2 -c
    '
    table = Array.new
    table << ['Jobs','End','User','Accounts','State','Nodes']
    System::exec(command).split("\n").each do |line|
      table << line.split(' ')
    end
    $stdout.puts CLI::Table.print(table)
  end

  def self.failed
    command = '
      sacct
        --noheader --allocations --allusers
        --starttime $(date --date="14 days ago" +"%Y-%m-%d")
        --state failed,node_fail,timeout
        --format end,user,account,state,exitcode
        | sort -k 1
        | uniq -f 1 -c
    '
    table = Array.new
    table << ['Jobs','End','User','Account','State','Exit Code']
    System::exec(command).split("\n").each do |line|
      table << line.split(' ')
    end
    $stdout.puts CLI::Table.print(table)
  end

end

class Nodes

  def self.idle
    command = "
      sinfo 
        --format='%o|%T|%P|%L|%l|%m|%z|%h|%f|%G' 
        --noheader
        --state=idle
        --sort o
    "
    table = Array.new
    table << ['Node','State','Partition','Time','Limit','RAM','S;C:T','Share','Features','GRES']
    System::exec(command).split("\n").each do |line|
      table << line.split('|').map! { |e| e.strip }
    end
    $stdout.puts CLI::Table.print(table)
  end
  
  def self.allocated
    command = "
      sinfo 
        --format='%o|%T|%P|%O|%C' 
        --noheader
        --state=allocated
        --sort o
    "
    table = Array.new
    table << ['Node','State','Partition','Load','CPUs (A/I/O/T)']
    System::exec(command).split("\n").each do |line|
      line = line.split('|').map! { |e| e.strip }
      table << line.map! { |e| e.strip } unless line[0].empty?
    end
    $stdout.puts CLI::Table.print(table)
  end

  def self.defects
    command = "
      sinfo 
        --format '%5D|%10T|%100N|%7u|%E' 
        --noheader
        -S 'T,E' 
        -t drain,down
    "
    table = Array.new
    table << ['Nodes','State','Nodeset','Admin','Reason']
    System::exec(command).split("\n").each do |line|
      table << line.split('|').map! { |e| e.strip }
    end
    $stdout.puts CLI::Table.print(table)
  end

  def self.users
    command = "
      squeue 
        --noheader
        --states RUNNING
        --sort 'N'
        --format '%N|%D|%u|%a|%M|%L|%Z|%o'
    "
    table = Array.new
    table << ['Nodeset','Nodes','User','Account','Run Time','Time Left','Working Directory','Executed']
    System::exec(command).split("\n").each do |line|
      table << line.split('|').map! { |e| e.strip }
    end
    system "echo \"#{CLI::Table.print(table)}\" | less --quit-on-intr --chop-long-lines"
  end

end

class Report

  def self.top_user
    command = '
      sreport user top 
        start=$(date --date="30 days ago" +"%Y-%m-%d") 
        format="login,account,used" 
        topcount=100 
        --noheader
    '
    table = Array.new
    table << ['User','Account','CPU Time']
    System::exec(command).split("\n").each do |line|
      table << line.split(' ').map! { |e| e.strip }
    end
    $stdout.puts CLI::Table.print(table)
  end

  def self.account
    command = '
      sreport cluster accountutilizationbyuser 
        start=$(date --date="30 days ago" +"%Y-%m-%d") 
        format="account,login,used"
        --noheader
    '
    table = Array.new
    table << ['Account','User','CPU Time']
    System::exec(command).split("\n").each do |line|
      line = line.split(' ').map! { |e| e.strip }
      if line.length == 2
        table << [ line[0], '-', line[1]  ]
      else
        table << line
      end
    end
    $stdout.puts CLI::Table.print(table)
  end

end


begin

  #stdin = $stdin.tty? ? String.new : $stdin.read

  options = OpenStruct.new
  options.debug = false

  $logger = Logger.new($stderr)
  # Adjust the time format used for the logger
  $logger.datetime_format = "%Y-%m-%d %H:%M:%S "
  $logger.formatter = proc do |severity, datetime, progname, message|
    "[#{datetime.strftime($logger.datetime_format)}] #{severity} -- #{message}\n"
  end
  $logger.level = Logger::INFO

  GetoptLong.new(
    ['--debug','-d',GetoptLong::NO_ARGUMENT],
    ['--help','-h',GetoptLong::NO_ARGUMENT],
    ['--log-level','-L',GetoptLong::REQUIRED_ARGUMENT],
    ['--version','-v',GetoptLong::NO_ARGUMENT]
  ).each do |opt,arg|
    case opt
    when '--debug'
      options.debug = true
      $logger.level = Logger::DEBUG
    when '--help'
      $stdout.puts HELP
      exit 0
    when '--log-level'
      $logger.level = case arg
      when 'warn'
        Logger::WARN
      when 'debug'
        Logger::DEBUG
      when 'fatal'
        Logger::FATAL
      else
        Logger::INFO
       end
    when '--version'
      $stdout.puts 0.1
      exit 0
    end
  end

  command = ARGV.shift || 'help'
  case command
  when 'j','jobs'
     subcommand = ARGV.shift || 'running'
     case subcommand
     when 'p','pend','pending'
       Jobs::pending
     when 'c','comp','completed'
       Jobs::completed
     when 'r','run','running'
       Jobs::running
     when 'f', 'fail', 'failed'
       Jobs::failed
     else
       raise("Sub-command #{subcommand} not supported") 
     end
  when 'n','nodes'
     subcommand = ARGV.shift || 'idle'
     case subcommand
     when 'a','alloc','allocated'
       Nodes::allocated
     when 'd','defects'
       Nodes::defects
     when 'i','idle'
       Nodes::idle
     when 'u','users'
       Nodes::users
     end
  when 'r','report'
     subcommand = ARGV.shift || 'top'
     case subcommand
     when 'a','account'
       Report::account
     when 'u','users'
       Report::top_user
     end
  when 'help'
      $stdout.puts HELP
      exit 0
  end


rescue => exc
  $stderr.puts "ERROR: #{exc.message}"
  $stderr.puts " use -h for detailed instructions"
  if options.debug
    $stderr.puts '-- Stack Trace --'
    $stderr.puts exc.backtrace
  else
    $stderr.puts 'You may want run this in debug mode with \'-d\''
  end
  exit 1
end

exit 0
