# Standard Input/Output (STDIO)

Topics:

* Composability
* Standard I/O Streams
* Pipelines
* I/O Redirection
* File Descriptors

---

## Composability

A composable program architecture allows to **chain multiple programs**.

This idea is integral to the "[Unix philosophy][unp]":

* Write programs that do one thing and do it well.
* Write programs to work together.
* Write programs to handle text streams (a universal interface).

A key character is **`|` (pipe)**:

```bash
a | b   # run a and b, send output of a as input to b, print output of b
a | b | c ...  # chained pipelines can build complex process structures
```

Programs (processes) have **three data streams**:

1. `STDIN` - **Input** read by a program
2. `STDOUT` - **Output** generated by a program
3. `STDERR` - 2nd output for **errors** messages & **debug** diagnostics

**[Redirection][redir]** is used to composes **interprocess communication**.

[unp]: https://en.wikipedia.org/wiki/Unix_philosophy
[redir]: https://en.wikipedia.org/wiki/Redirection_(computing)

---

## Input/Output Redirection 


STDIO data streams **automatically opened** at program start:

* `STDIN`  - Usually input from the **keyboard**, can be a redirect from file(s)
* `STDOUT` - Output to **console** (display) and/or redirected to file(s)/program(s)
* `STDERR` - Also sent to console or redirected to a **log** file

I/O streams identified by an **integer [file descriptor][fld]** (file handle):

Integer    | Name            | Stream
-----------|-----------------|-----------------------
0          | Standard input  | `STDIN`
1          | Standard output | `STDOUT`
2          | Standard error  | `STDERR`

Redirect streams between programs and files:

```bash
a | b   # STDOUT of program a to STDIN of process b
a > f   # STDOUT of program a to file f (same as a 1> f)
a >> f  # append STDOUT of program a to file f
a < f   # input content of file f to STDIN of program a (same as a 0< f)
```

[fld]: https://en.wikipedia.org/wiki/File_descriptor

???

---

## Why is this useful? An example...


Print the host IP configuration with the `ip` command, and limit 
its output to the first five lines with the `head` command:

```bash
» ip addr | head -n 5 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN ...
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
```

Select a subset of the output matching a pattern with the `grep` command:

```bash
» ip addr | grep 'inet '                 
    inet 127.0.0.1/8 scope host lo
    inet 140.181.84.103/18 brd 140.181.127.255 scope global dynamic eno1
    inet 10.1.1.1/24 brd 10.1.1.255 scope global nbr0
```

Limit the output to specific columns using `awk` (text-processor):

```bash
» ip addr | grep 'inet ' | awk '{print $2 " " $NF}'
127.0.0.1/8 lo
140.181.84.103/18 eno1
10.1.1.1/24 nbr0
```

---

## Composability (2)

Shells provide a **versatile way to compose programs**:

```bash
> f                   # create an empty file f from empty STDIN (:> f)
a 1>&-                # close STDOUT of program a
a 2> f                # write STDERR of program a to file f
a > f 2>&1            # write STDOUT & STDERR of program a to file f
a &> f                # ...same as above, in a short notation
# redirect content of file f to STDIN of program a, and...
a < f > g             #...write STDOUT or program a to file g  
{a ; b} > f           # redirect STDOUT of programs a and b to file f
a |& b                # pipe STDOUT & STDERR of program a to STDIN of program b
a | tee f             # redirect STDOUT of program a to console and file f
a |:                  # redirect STDOUT & STDERR to pipeline sink (&>/dev/null)
```

Redirect **to/from a sub-shell**:

```bash
a <(b)                # redirect STDOUT of program b to STDIN of program a
a >(b)                # redirect STDOUT of program a to STDIN of program b
(a ; b) > f           # redirect STDOUT of programs a and b to file f
# redirect STDOUT of program a to STDIN of program b and c...
a >(b > f) >(c > g)   #...both programs a and b write to files f and g
```



---

## File Descriptors

Simple example script with **permanent output redirection**:


```bash
#!/usr/bin/env bash
# write STDOUT to file (temporary redirect for a single command)
echo one 1>/tmp/file
# permanent redirect (append) STDOUT to file from here one
exec 1>>/tmp/file
echo two
echo three
```

The `exec` program is used it **opening file descriptors**:

```bash
exec 3< f          # open file f for reading on file descriptor  3
exec 8<> f         # open file f for reading and writing on file descriptor 8
exec 6>> f         # open file f for appending on file descriptor 6
exec 5<&0          # copy read file descriptor 0 onto file descriptor 5
exec 7>&4          # copy write file descriptor 4 onto 7
exec 3<&-          # close the read file descriptor 3
exec 6>&-          # close the write file descriptor 6
```

**Preserve references to `STDOUT` and `STDIN`** file descriptors:

```bash
exec 3>&1 ; exec 4>&2         # preserve
# ...run code here...
exec 2>&4 ; exec 1>&3         # reset
```
