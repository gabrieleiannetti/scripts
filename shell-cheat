#!/bin/sh

T="\033[1;4m"
R="\033[0m"

echo "
${T}BUILD-IN COMMANDS${R}

set -v         print shell input lines as they are read
set -x         print commands and their arguments when executed
set -f         disable globbing
source f       execute file f in current shell environment
echo \"s\"       prints string s to screen
echo -n \"s\"    prints string s to screen without linefeed
export V=v     set global variable V to value v
local V=v      set variable V to value v locally in function         
dirs           show all directories in stack
cd ~n          go to nth directory in stack
pushd d        add directory d to stack
popd           remove directory from stack
jobs           list active jobs associated with current shell
disown         detach jobs from current shell
bg             move job to background 
fg j           resume job j to foreground
stop j         stops background job j
nohup          continue job after logout
eval \`c\`       execute command c in sub-shell and evaluate
read v         read value into v
trap c s       execute command c when catching signal s
shift          remove leading positional parameter

${T}EXPRESSIONS & VARIABLES${R}

#              mark line as comment
;              statement separator
\              escape character (preserves the literal value)
's'            preserves the literal value of all characters
               in string s
\"s\"            preserves the literal value of all characters
               in string s except $, \, and ,
$'s'           expands string s with with backslash-escaped 
               characters replaced
:              nil-statement returns 0
|              pipeline (input-output-connection)
V=v            assign value v to variable V (no spaces allowed)
\${V}           expand variable V (curly braces optional)
\${V:-v}        use variable V if set, otherwise use value v
\${V:=v}        use variable V if set, otherwise set V to value v
\${V:+v}        use value v if variable V is set
\${V:?M}        print message M unless variable V is set
\${#V}          length of variable V
\${v%P}         remove shortest match of pattern P from the end  
\${v%%P}        remove longest match of pattern P from the end
\${v#P}         remove shortest match of pattern P from the beginning
\${v##P}        remove longest match of pattern P from the beginning
\$(c)           execute command c in sub-shell (alternative \`c\`)
((e))          arithmetic evaluation of expression e
[[e]]          returns true of false after evaluation 
               of the conditional expression e
!e             true if expression e is false
e1 && e2       true if both expressions e1 and e2 are true
               (alternative e1 -a e2)
e1 || e2       true if either expression e1 or e2 is true
               (alternative e1 -o e2)
{s;}           anonymous subroutine
f() {s;}       named subroutine (parameters in parentheses options;
               key-word \`function\` optional)
c &            execute command c in background
c1 && c2       if command c1 runs successful execute c2
c1 || c2       if command c1 runs not successful execute c2
c1 & c2        run commands c1 and c2 in parallel
c1; c2         execute command c1 before c2
{c1; c2}       execute commands in current shell environment
(c1; c2)       execute the commands inside a sub-shell environment
c1 \`c2\`        command c1 uses output of c2 as parameters
\${a[i]}        use element i from array a
\${a}           use element 0 from array a
\${a[*]}        use all elements from array a
\$1...\$n        direct access to parameters n
\$@             all parameters
\"\$@\"           each parameter in double-quotes (\"\$1\" \"\$2\"...)
\"\$*\"           all parameters in double-quotes (\"\$1 \$2...\")
\$#             number of parameters
\$?             most recent exit status
\$$             current shell process ID
\$!             most recent process ID
\$0             name of executed script
\$_             absolute path to executed script
\$HOME          user home directory
\$PWD           current directory
\$IFS           list of field separators

${T}PRIMARY EXPRESSIONS${R}

n1 -lt n2       true if n1 less then n2
n1 -gt n2       true if n1 greater then n2
n1 -le n2       true if n1 less or equal n2
n1 -ge n2       true if n1 greater or equal n2
n1 -eq n2       true if n1 equals n2
n1 -ne n2       true if n1 not equal n2
s1 = s2         true if strings s1 equals s2 
s1 != s2        true if strings s1 not equal s2
-n s            true if string s is not empty
-z s            true if string s is empty
-c f            true if f is a special character file
-d p            true if p is the path to an existing directory
-e f            true if f is an existing file
-f f            true if f is an existing file but not an directory
-G f            true if f exists and is owned by effective group-id
-g f            true if f exists and is set-group-id.
-k f            true if f has sticky bit
-L f            true if f is a symbolic link
-O f            true if f exists and is owned by the effective user-id.
-r f            true if f is readable
-S f            true if f is socket
-s f            true if f nonzero size
-u f            true if f set-user-id bit is set
-w f            true if f is writable
-x f            true if f is executable

${T}CONTROL STRUCTURES & LOOP CONSTRUCTS${R}

if [ e1 ] ; then ; elif [ e2 ] ; then ; else ; fi
case e in ; c1) ;; c2 | c3) ;; *) ;; esac 
for i in \$( list ) ; do ; done
for (( e1; e2; e3 )); do ; done 
while [ e ] ; do ; done
until [ e ] ; do ; done

${T}OUTPUT STREAMING${R}

cmd > file            stdout to file
cmd >> file           append stdout to file
cmd < file            file to stdin
cmd >&-               close stdout
cmd 2> file           stderr to file
cmd > file 2>&1       stdout/stderr to file
cmd | tee file        stdout to screen and file
cmd 2>&1 | tee file   stdout/stderr to screen and file
"
